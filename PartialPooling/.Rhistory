beta_prior_var*Imat
Imat
source('~/Box Sync/Research/Analyses/ZeroInf_BNP_reg/code/G_comp_Full_SourceCode.R')
EY_1 <- bnp_standardization(DPmix_res = DPglm_res, iter=1000,
interv_var = 'trt', interv_val = 1)
source('~/Box Sync/Research/Analyses/ZeroInf_BNP_reg/code/G_comp_Full_SourceCode.R')
EY_1 <- bnp_standardization(DPmix_res = DPglm_res, iter=1000,
interv_var = 'trt', interv_val = 1)
Imat
source('~/Box Sync/Research/Analyses/ZeroInf_BNP_reg/code/G_comp_Full_SourceCode.R')
EY_1 <- bnp_standardization(DPmix_res = DPglm_res, iter=1000,
interv_var = 'trt', interv_val = 1)
DPglm_res$param_shell[[i]]$param_z[, class, drop=F]
xz_vec
xz_vec %*% DPglm_res$param_shell[[i]]$param_z[, class, drop=F]
source('~/Box Sync/Research/Analyses/ZeroInf_BNP_reg/code/G_comp_Full_SourceCode.R')
EY_1 <- bnp_standardization(DPmix_res = DPglm_res, iter=1000,
interv_var = 'trt', interv_val = 1)
source('~/Box Sync/Research/Analyses/ZeroInf_BNP_reg/code/G_comp_Full_SourceCode.R')
EY_1 <- bnp_standardization(DPmix_res = DPglm_res, iter=1000,
interv_var = 'trt', interv_val = 1)
source('~/Box Sync/Research/Analyses/ZeroInf_BNP_reg/code/G_comp_Full_SourceCode.R')
EY_1 <- bnp_standardization(DPmix_res = DPglm_res, iter=1000,
interv_var = 'trt', interv_val = 1)
xz_vec
source('~/Box Sync/Research/Analyses/ZeroInf_BNP_reg/code/G_comp_Full_SourceCode.R')
EY_1 <- bnp_standardization(DPmix_res = DPglm_res, iter=1000,
interv_var = 'trt', interv_val = 1)
source('~/Box Sync/Research/Analyses/ZeroInf_BNP_reg/code/G_comp_Full_SourceCode.R')
EY_1 <- bnp_standardization(DPmix_res = DPglm_res, iter=1000,
interv_var = 'trt', interv_val = 1)
source('~/Box Sync/Research/Analyses/ZeroInf_BNP_reg/code/G_comp_Full_SourceCode.R')
EY_1 <- bnp_standardization(DPmix_res = DPglm_res, iter=1000,
interv_var = 'trt', interv_val = 1)
source('~/Box Sync/Research/Analyses/ZeroInf_BNP_reg/code/G_comp_Full_SourceCode.R')
EY_1 <- bnp_standardization(DPmix_res = DPglm_res, iter=1000,
interv_var = 'trt', interv_val = 1)
gamma_new
t(gamma_new)
beta_new
source('~/Box Sync/Research/Analyses/ZeroInf_BNP_reg/code/G_comp_Full_SourceCode.R')
source('~/Box Sync/Research/Analyses/ZeroInf_BNP_reg/code/G_comp_Full_SourceCode.R')
EY_1 <- bnp_standardization(DPmix_res = DPglm_res, iter=1000,
interv_var = 'trt', interv_val = 1)
source('~/Box Sync/Research/Analyses/ZeroInf_BNP_reg/code/G_comp_Full_SourceCode.R')
EY_1 <- bnp_standardization(DPmix_res = DPglm_res, iter=1000,
interv_var = 'trt', interv_val = 1)
source('~/Box Sync/Research/Analyses/ZeroInf_BNP_reg/code/G_comp_Full_SourceCode.R')
set.seed(1)
EY_1 <- bnp_standardization(DPmix_res = DPglm_res, iter=1000,
interv_var = 'trt', interv_val = 1)
source('~/Box Sync/Research/Analyses/ZeroInf_BNP_reg/code/G_comp_Full_SourceCode.R')
set.seed(1)
EY_1 <- bnp_standardization(DPmix_res = DPglm_res, iter=1000,
interv_var = 'trt', interv_val = 1)
source('~/Box Sync/Research/Analyses/ZeroInf_BNP_reg/code/G_comp_Full_SourceCode.R')
set.seed(1)
EY_1 <- bnp_standardization(DPmix_res = DPglm_res, iter=1000,
interv_var = 'trt', interv_val = 1)
DPglm_res$param_shell[[i]]$param_z[, class, drop=F]
class
DPglm_res$param_shell[[i]]$param_z
pvec
table(c_shell[,1])
DPglm_res$param_shell[[1]]$param_z
DPglm_res$param_shell[[2]]$param_z
source('~/Box Sync/Research/Analyses/ZeroInf_BNP_reg/code/G_comp_Full_SourceCode.R')
set.seed(1)
EY_1 <- bnp_standardization(DPmix_res = DPglm_res, iter=1000,
interv_var = 'trt', interv_val = 1)
warnings()
source('~/Box Sync/Research/Analyses/ZeroInf_BNP_reg/code/G_comp_Full_SourceCode.R')
set.seed(1)
EY_1 <- bnp_standardization(DPmix_res = DPglm_res, iter=1000,
interv_var = 'trt', interv_val = 1)
x_vec
interv_var
source('~/Box Sync/Research/Analyses/ZeroInf_BNP_reg/code/G_comp_Full_SourceCode.R')
set.seed(1)
EY_1 <- bnp_standardization(DPmix_res = DPglm_res, iter=1000,
interv_var = 'trt', interv_val = 1)
xz_vec
x_vec
source('~/Box Sync/Research/Analyses/ZeroInf_BNP_reg/code/G_comp_Full_SourceCode.R')
source('~/Box Sync/Research/Analyses/ZeroInf_BNP_reg/code/G_comp_Full_SourceCode.R')
set.seed(1)
EY_1 <- bnp_standardization(DPmix_res = DPglm_res, iter=1000,
interv_var = 'trt', interv_val = 1)
x_vec
source('~/Box Sync/Research/Analyses/ZeroInf_BNP_reg/code/G_comp_Full_SourceCode.R')
set.seed(1)
EY_1 <- bnp_standardization(DPmix_res = DPglm_res, iter=1000,
interv_var = 'trt', interv_val = 1)
x_vec
2:(nparams-1)
nparams
x_vec
nparams
nparams-1
source('~/Box Sync/Research/Analyses/ZeroInf_BNP_reg/code/G_comp_Full_SourceCode.R')
set.seed(1)
EY_1 <- bnp_standardization(DPmix_res = DPglm_res, iter=1000,
interv_var = 'trt', interv_val = 1)
x_vec
source('~/Box Sync/Research/Analyses/ZeroInf_BNP_reg/code/G_comp_Full_SourceCode.R')
set.seed(1)
EY_1 <- bnp_standardization(DPmix_res = DPglm_res, iter=1000,
interv_var = 'trt', interv_val = 1)
source('~/Box Sync/Research/Analyses/ZeroInf_BNP_reg/code/G_comp_Full_SourceCode.R')
set.seed(1)
EY_1 <- bnp_standardization(DPmix_res = DPglm_res, iter=1000,
interv_var = 'trt', interv_val = 1)
source('~/Box Sync/Research/Analyses/ZeroInf_BNP_reg/code/G_comp_Full_SourceCode.R')
set.seed(1)
EY_1 <- bnp_standardization(DPmix_res = DPglm_res, iter=1000,
interv_var = 'trt', interv_val = 1)
source('~/Box Sync/Research/Analyses/ZeroInf_BNP_reg/code/G_comp_Full_SourceCode.R')
set.seed(1)
EY_1 <- bnp_standardization(DPmix_res = DPglm_res, iter=1000,
interv_var = 'trt', interv_val = 1)
par(mfrow=c(3,1))
hist(EY_1,breaks=60)
abline(v=EY_1_true, lwd=2, col='red')
par(mfrow=c(1,1))
hist(EY_1,breaks=60)
plot(EY_1, type='l')
EY_1_true <- true_standard(interv_var = 'trt', interv_val = 1,
iter=10000000, covar_names = c('age', 'trt'))
EY_0_true <- true_standard(interv_var = 'trt', interv_val = 0,
iter=10000000, covar_names = c('age', 'trt'))
delta <- EY_1_true - EY_0_true
delta
abline(h = EY_1_true, col='red', lwd=3)
library(nimble)
setwd("/Users/aoganisi/Dropbox/Stable Markets/BayesianTutorials/PartialPooling")
################################################################################
#####                       Simulate Data                                  #####
################################################################################
set.seed(10)
d_A<-rbinom(n = 5,  size = 1, prob =  .2)
d_B<-rbinom(n = 100, size = 1, prob = .3)
d_C<-rbinom(n = 5, size = 1, prob = .45)
d_D<-rbinom(n = 100, size = 1, prob = .7)
d_E<-rbinom(n = 5, size = 1, prob = .8)
approve <- c(d_A, d_B, d_C, d_D, d_E)
industry <- as.factor(c(rep('A', 5),  rep('B', 100), rep('C', 5),
rep('D', 100), rep('E', 5) ))
mod_mat <- model.matrix(lm(approve ~ industry))
d_list <- list(X = mod_mat,
approve = approve)
p <- ncol(mod_mat)
n <- nrow(mod_mat)
################################################################################
#####                       Bayesian Esimtate                              #####
################################################################################
code <- nimbleCode({
for(i in 1:p){
beta[i] ~ dnorm(0, 2)
}
logit(eta[1:n]) <- X[1:n,1:p] %*% beta[1:p]
for(i in 1:n) {
approve[i] ~ dbern(prob = eta[i] )
}
p_approve[1] <- beta[1]
p_approve[2] <- beta[1] + beta[2]
p_approve[3] <- beta[1] + beta[3]
p_approve[4] <- beta[1] + beta[4]
p_approve[5] <- beta[1] + beta[5]
})
merge_model <- nimbleModel(code=code,
constants=list(p=p, n=n),
inits = list(beta=c(0,0,0,0,0)),
data=d_list)
spec <- configureMCMC(merge_model)
spec$addSampler(type = 'RW_block', target ='beta')
spec$monitors <- c('p_approve')
mcmc <- buildMCMC(spec)
Cmodel <- compileNimble(merge_model)
Cmcmc <- compileNimble(mcmc, project = merge_model)
Cmcmc$run(10000)
samples <- as.matrix(Cmcmc$mvSamples)
summary(samples)
### no pooling
no_pool_res <- glm(approve ~ industry, family = binomial(link = 'logit'))
vcov(no_pool_res)
?run
compiled_mcmc
compiled_mcmc
compiled_mcmc <- compileNimble(mcmc, project = merge_model)
compiled_mcmc
compiled_mcmc$trace
compiled_mcmc$thin
spec <- configureMCMC(merge_model)
spec$controlDefaults
summary(compiled_mcmc)
summary(compiled_mcmc$run(1000))
compiled_mcmc$mvSamples2
mcmc <- buildMCMC(spec,burnin=1000)
compiled_model <- compileNimble(merge_model)
compiled_mcmc <- compileNimble(mcmc, project = merge_model)
compiled_mcmc$run(10000)
samples <- as.matrix(compiled_mcmc$mvSamples)
summary(samples)
?buildMCMC
?configureMCMC
merge_model <- nimbleModel(code=code,
constants=list(p=p, n=n),
inits = list(beta=c(0,0,0,0,0)),
data=d_list)
spec <- configureMCMC(merge_model)
spec$set
spec$addSampler(type = 'RW_block', target ='beta',
control = list(targetNodes='beta',
adaptive = TRUE ))
spec$monitors <- c('p_approve')
mcmc <- buildMCMC(spec,)
compiled_model <- compileNimble(merge_model)
compiled_mcmc <- compileNimble(mcmc, project = merge_model)
compiled_mcmc$run(10000)
samples <- as.matrix(compiled_mcmc$mvSamples)
summary(samples)
merge_model <- nimbleModel(code=code,
constants=list(p=p, n=n),
inits = list(beta=c(0,0,0,0,0)),
data=d_list)
spec <- configureMCMC(merge_model)
spec$set
spec$addSampler(type = 'RW_block', target ='beta',
control = list(targetNodes='beta',
adaptive = TRUE ))
spec$monitors <- c('p_approve')
mcmc <- buildMCMC(spec)
compiled_model <- compileNimble(merge_model)
samples <- as.matrix(compiled_mcmc$mvSamples)
summary(samples)
code <- nimbleCode({
for(i in 1:p){
beta[i] ~ dnorm(0, 2)
}
logit(eta[1:n]) <- X[1:n,1:p] %*% beta[1:p]
for(i in 1:n) {
approve[i] ~ dbern(prob = eta[i] )
}
p_approve[1] <- expit(beta[1])
p_approve[2] <- expit(beta[1] + beta[2])
p_approve[3] <- expit(beta[1] + beta[3])
p_approve[4] <- expit(beta[1] + beta[4])
p_approve[5] <- expit(beta[1] + beta[5])
})
merge_model <- nimbleModel(code=code,
constants=list(p=p, n=n),
inits = list(beta=c(0,0,0,0,0)),
data=d_list)
spec <- configureMCMC(merge_model)
spec$addSampler(type = 'RW_block', target ='beta',
control = list(targetNodes='beta',
adaptive = TRUE ))
spec$monitors <- c('p_approve')
mcmc <- buildMCMC(spec)
compiled_model <- compileNimble(merge_model)
compiled_mcmc <- compileNimble(mcmc, project = merge_model)
compiled_mcmc$run(10000)
samples <- as.matrix(compiled_mcmc$mvSamples)
summary(samples)
partial_pool_p <- colMeans(samples)
### no pooling
no_pool_res <- glm(approve ~ industry, family = binomial(link = 'logit'))
# compute probabilities of merger for each industry separately.
no_pooled_p <- predict(no_pool_res,
newdata = data.frame(industry=as.factor(c('A','B','C','D','E') )),
type = 'response')
### complete pooling
pool_res <- glm(approve ~ 1, family = binomial(link = 'logit'))
# compute probability of merger across all idustries, pooled.
pooled_p <- exp(pool_res$coefficients)/(1 + exp(pool_res$coefficients))
plot(partial_pool_p, pch=20, col='red', ylim=c(0,1), axes=F,
xlab='Industry', ylab='Probability of Merger')
axis(1, at = 1:5, labels = paste0(partial_pool_p$industry, " (n =",c(5,10,20,10,5),')' ) )
axis(2, at = seq(0,1,.2), labels= seq(0,1,.2) )
points(1:5, no_pooled_p, pch=20, col='black')
abline(h=pooled_p, lty=2)
legend('bottomright',
legend = c('Pooled Estimate','Stratified Estimates', 'Bayesian Estimate'),
lty = c(2,NA,NA), col=c('black','black','red'), pch=c(NA, 20,20), bty='n')
plot(partial_pool_p, pch=20, col='red', ylim=c(0,1), axes=F,
xlab='Industry', ylab='Probability of Merger')
axis(1, at = 1:5, labels = paste0(unique(industry), " (n =",c(5,10,20,10,5),')' ) )
axis(2, at = seq(0,1,.2), labels= seq(0,1,.2) )
points(1:5, no_pooled_p, pch=20, col='black')
abline(h=pooled_p, lty=2)
legend('bottomright',
legend = c('Pooled Estimate','Stratified Estimates', 'Bayesian Estimate'),
lty = c(2,NA,NA), col=c('black','black','red'), pch=c(NA, 20,20), bty='n')
plot(partial_pool_p, pch=20, col='red', ylim=c(0,1), axes=F,
xlab='Industry', ylab='Probability of Merger')
axis(1, at = 1:5, labels = paste0(unique(industry), " (n =",c(5,100,5,100,5),')' ) )
axis(2, at = seq(0,1,.2), labels= seq(0,1,.2) )
points(1:5, no_pooled_p, pch=20, col='black')
abline(h=pooled_p, lty=2)
legend('bottomright',
legend = c('Pooled Estimate','Stratified Estimates', 'Bayesian Estimate'),
lty = c(2,NA,NA), col=c('black','black','red'), pch=c(NA, 20,20), bty='n')
code <- nimbleCode({
for(i in 1:p){
beta[i] ~ dnorm(0, 3)
}
logit(eta[1:n]) <- X[1:n,1:p] %*% beta[1:p]
for(i in 1:n) {
approve[i] ~ dbern(prob = eta[i] )
}
p_approve[1] <- expit(beta[1])
p_approve[2] <- expit(beta[1] + beta[2])
p_approve[3] <- expit(beta[1] + beta[3])
p_approve[4] <- expit(beta[1] + beta[4])
p_approve[5] <- expit(beta[1] + beta[5])
})
merge_model <- nimbleModel(code=code,
constants=list(p=p, n=n),
inits = list(beta=c(0,0,0,0,0)),
data=d_list)
spec <- configureMCMC(merge_model)
spec$addSampler(type = 'RW_block', target ='beta',
control = list(targetNodes='beta',
adaptive = TRUE ))
spec$monitors <- c('p_approve')
mcmc <- buildMCMC(spec)
compiled_model <- compileNimble(merge_model)
compiled_mcmc <- compileNimble(mcmc, project = merge_model)
compiled_mcmc$run(10000)
samples <- as.matrix(compiled_mcmc$mvSamples)
summary(samples)
partial_pool_p <- colMeans(samples)
################################################################################
#####                       Frequentist Estimates                          #####
################################################################################
### no pooling
no_pool_res <- glm(approve ~ industry, family = binomial(link = 'logit'))
# compute probabilities of merger for each industry separately.
no_pooled_p <- predict(no_pool_res,
newdata = data.frame(industry=as.factor(c('A','B','C','D','E') )),
type = 'response')
### complete pooling
pool_res <- glm(approve ~ 1, family = binomial(link = 'logit'))
# compute probability of merger across all idustries, pooled.
pooled_p <- exp(pool_res$coefficients)/(1 + exp(pool_res$coefficients))
################################################################################
#####                       Visualize Results                              #####
################################################################################
plot(partial_pool_p, pch=20, col='red', ylim=c(0,1), axes=F,
xlab='Industry', ylab='Probability of Merger')
axis(1, at = 1:5, labels = paste0(unique(industry), " (n =",c(5,100,5,100,5),')' ) )
axis(2, at = seq(0,1,.2), labels= seq(0,1,.2) )
points(1:5, no_pooled_p, pch=20, col='black')
abline(h=pooled_p, lty=2)
legend('bottomright',
legend = c('Pooled Estimate','Stratified Estimates', 'Bayesian Estimate'),
lty = c(2,NA,NA), col=c('black','black','red'), pch=c(NA, 20,20), bty='n')
partial_pool_p <- colMeans(samples[5000:10000,])
################################################################################
#####                       Frequentist Estimates                          #####
################################################################################
### no pooling
no_pool_res <- glm(approve ~ industry, family = binomial(link = 'logit'))
# compute probabilities of merger for each industry separately.
no_pooled_p <- predict(no_pool_res,
newdata = data.frame(industry=as.factor(c('A','B','C','D','E') )),
type = 'response')
### complete pooling
pool_res <- glm(approve ~ 1, family = binomial(link = 'logit'))
# compute probability of merger across all idustries, pooled.
pooled_p <- exp(pool_res$coefficients)/(1 + exp(pool_res$coefficients))
################################################################################
#####                       Visualize Results                              #####
################################################################################
plot(partial_pool_p, pch=20, col='red', ylim=c(0,1), axes=F,
xlab='Industry', ylab='Probability of Merger')
axis(1, at = 1:5, labels = paste0(unique(industry), " (n =",c(5,100,5,100,5),')' ) )
axis(2, at = seq(0,1,.2), labels= seq(0,1,.2) )
points(1:5, no_pooled_p, pch=20, col='black')
abline(h=pooled_p, lty=2)
legend('bottomright',
legend = c('Pooled Estimate','Stratified Estimates', 'Bayesian Estimate'),
lty = c(2,NA,NA), col=c('black','black','red'), pch=c(NA, 20,20), bty='n')
library(nimble)
setwd("/Users/aoganisi/Dropbox/Stable Markets/BayesianTutorials/PartialPooling")
################################################################################
#####                       Simulate Data                                  #####
################################################################################
set.seed(10)
d_A<-rbinom(n = 10,  size = 1, prob =  .2)
d_B<-rbinom(n = 100, size = 1, prob = .3)
d_C<-rbinom(n = 10, size = 1, prob = .45)
d_D<-rbinom(n = 100, size = 1, prob = .7)
d_E<-rbinom(n = 10, size = 1, prob = .8)
approve <- c(d_A, d_B, d_C, d_D, d_E)
industry <- as.factor(c(rep('A', 10),  rep('B', 100), rep('C', 10),
rep('D', 100), rep('E', 10) ))
mod_mat <- model.matrix(lm(approve ~ industry))
d_list <- list(X = mod_mat,
approve = approve)
p <- ncol(mod_mat)
n <- nrow(mod_mat)
################################################################################
#####                       Bayesian Esimtate                              #####
################################################################################
code <- nimbleCode({
for(i in 1:p){
beta[i] ~ dnorm(0, 3)
}
logit(eta[1:n]) <- X[1:n,1:p] %*% beta[1:p]
for(i in 1:n) {
approve[i] ~ dbern(prob = eta[i] )
}
p_approve[1] <- expit(beta[1])
p_approve[2] <- expit(beta[1] + beta[2])
p_approve[3] <- expit(beta[1] + beta[3])
p_approve[4] <- expit(beta[1] + beta[4])
p_approve[5] <- expit(beta[1] + beta[5])
})
merge_model <- nimbleModel(code=code,
constants=list(p=p, n=n),
inits = list(beta=c(0,0,0,0,0)),
data=d_list)
spec <- configureMCMC(merge_model)
spec$addSampler(type = 'RW_block', target ='beta',
control = list(targetNodes='beta',
adaptive = TRUE ))
spec$monitors <- c('p_approve')
mcmc <- buildMCMC(spec)
compiled_model <- compileNimble(merge_model)
compiled_mcmc <- compileNimble(mcmc, project = merge_model)
compiled_mcmc$run(10000)
samples <- as.matrix(compiled_mcmc$mvSamples)
summary(samples)
partial_pool_p <- colMeans(samples[5000:10000,])
################################################################################
#####                       Frequentist Estimates                          #####
################################################################################
### no pooling
no_pool_res <- glm(approve ~ industry, family = binomial(link = 'logit'))
# compute probabilities of merger for each industry separately.
no_pooled_p <- predict(no_pool_res,
newdata = data.frame(industry=as.factor(c('A','B','C','D','E') )),
type = 'response')
### complete pooling
pool_res <- glm(approve ~ 1, family = binomial(link = 'logit'))
# compute probability of merger across all idustries, pooled.
pooled_p <- exp(pool_res$coefficients)/(1 + exp(pool_res$coefficients))
################################################################################
#####                       Visualize Results                              #####
################################################################################
plot(partial_pool_p, pch=20, col='red', ylim=c(0,1), axes=F,
xlab='Industry', ylab='Probability of Merger')
axis(1, at = 1:5, labels = paste0(unique(industry), " (n =",c(5,100,5,100,5),')' ) )
axis(2, at = seq(0,1,.2), labels= seq(0,1,.2) )
points(1:5, no_pooled_p, pch=20, col='black')
abline(h=pooled_p, lty=2)
legend('bottomright',
legend = c('Pooled Estimate','Stratified Estimates', 'Bayesian Estimate'),
lty = c(2,NA,NA), col=c('black','black','red'), pch=c(NA, 20,20), bty='n')
d_A
d_B
d_C
d_E
sum(d_E)
getwd()
png(filename = 'PartialPool.png')
plot(partial_pool_p, pch=20, col='red', ylim=c(0,1), axes=F,
xlab='Industry', ylab='Probability of Merger')
axis(1, at = 1:5, labels = paste0(unique(industry), " (n =",c(10,100,10,100,10),')' ) )
axis(2, at = seq(0,1,.2), labels= seq(0,1,.2) )
points(1:5, no_pooled_p, pch=20, col='black')
abline(h=pooled_p, lty=2)
legend('bottomright',
legend = c('Pooled Estimate','Stratified Estimates', 'Bayesian Estimate'),
lty = c(2,NA,NA), col=c('black','black','red'), pch=c(NA, 20,20), bty='n')
dev.off()
knitr::opts_chunk$set(echo = TRUE)
head(data.frame(approve, industry))
data.frame(approve, industry)[5:15,]
data.frame(approve, industry)[5:20,]
data.frame(approve, industry)[5:30,]
data.frame(approve, industry)[1:30,]
data.frame(approve, industry)[30:40,]
data.frame(approve, industry)[30:50,]
data.frame(approve, industry)[110:120,]
data.frame(approve, industry)[105:120,]
library(dplyr)
library(dplyr)
library(tidyr)
# glimpse of the data
data.frame(approve, industry)[105:120,]
data.frame(approve,industry) %>%
group_by(industry) %>%
summarise(mean(approve))
data.frame(approve,industry) %>%
group_by(industry) %>%
summarise(mean(approve), n())
data.frame(approve,industry) %>%
group_by(industry) %>%
summarise(mean(approve), n_mergers_started=n())
data.frame(approve,industry) %>%
group_by(industry) %>%
summarise(succes_rate=mean(approve), n_mergers_started=n())
mean(approve)
knitr::opts_chunk$set(echo = T, warning = F, error = F, message = F)
unpooled <- data.frame(approve,industry) %>%
group_by(industry) %>%
summarise(success_rate=mean(approve), n_mergers_started=n())
unpooled
sessionInfo()
getwd()
